
React Dom -> It is basically a bridge between your code and actual dom(browser dom) and that react dom manages how to do operations on actual dom .

Why react is considered declarative?
-> It describes what the UI should look like and react handles the updates.

Props-> Data pass to components using attributes. 
Porps pass data from parent component to deeply nested child component.



useState -> It is hook in react that is capable to store the memory
If you want to update the UI when a variable changes, use useState.
If we use variables then we loose the data because variable don't persist across rerenders.

VDom -> When react loads it creates virtual copy of actual dom.

So the react component actually unmmounts when we refresh the page or when we conditionally render the component {showTimer && <TimerComponent />}


Reconcillation-> It happens in two phase 
1. Render phase : All the state updates and function calls are noted.
2. commit phase : react will applyy the changes at once.

Reconciliation in React is the process of updating the real DOM to match the virtual DOM. so whenever there is a change in state, react compares the new virtual DOM with the previous one and updates only the changed parts of the real DOM.


React use batch update if there are multiple state updates in a single event or a function.

Prop drilling -> Passing properties to different components to reach the child.
drawback -> It passes unneccessary data through intermediate components. E.g., If we simply want to pass the data through parent to child.

State uplifting -> Pattern used to share state between multiple components. We can declared the state in the parent from where every component can access the state.

Advantage of State uplifting -> It prevent prop drilling by storing state in the parent component.

Context Api -> Is a feature in react that provides a way to share data across the component tree without explicitly passing props.
It simply allow global state management without prop drilling.


REACT Router DOM-> It enables navigation between different components without reloading the page.

useRef hook -> Same as useState but it does not cause rerender. It can manipulate the dom elements and also tracks the state.   

useReducer -> Used to manage the complex and multiple states inside a single function.
dispatch funtion -> It triggers an state change by sending an action.


e.preventDefault() in forms -> So the behaviour of form is to  reload the whole page when it is submitted so to stop that in react we use it and it maintain the react SPA behaviour.


useState: simple, local state.
Context: avoids prop drilling, good for global but simple state.
useReducer: organizes complex state transitions.
Context + useReducer: global + complex state, good middle ground.
Redux: for very large, complex apps needing scalability, debugging, and middleware.


Pure functions-> functions which simply adheres two principles 
1. same input same output (It does not rely on external state or variables).
2. no side effects 


Why use midddleware in redux ->
To intercepts dispatched actions before they reach the reducer.
OR
Because it intercepting dispatched actions to perform tasks like handling asynchronous operations (e.g., API calls), logging actions, reporting errors before they reach the reducer. 



